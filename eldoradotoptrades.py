#!/usr/bin/env python3
"""List top tickers from trade history.

The script searches ``./tickers/<LETTER>/<TICKER>.csv`` for per ticker
trade summaries generated by :mod:`backtest`. It filters rows between the
specified ``--start`` and ``--end`` dates, matching the ``--range``
value when an ``open_range_minutes`` or ``range`` column is present.
Tickers are ordered by the column specified with ``--sort`` and only
included when that column's value is greater than ``--min-sort``.
"""

from __future__ import annotations

import argparse
from pathlib import Path
from typing import Iterable

import pandas as pd

try:
    from tabulate import tabulate
except Exception:  # ImportError or other
    tabulate = None


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="List top tickers from trades")
    parser.add_argument("--start", required=True, help="Start date YYYY-MM-DD")
    parser.add_argument("--end", required=True, help="End date YYYY-MM-DD")
    parser.add_argument(
        "--range",
        type=int,
        default=30,
        help="Opening range minutes (default 30)",
    )
    parser.add_argument(
        "--sort",
        default="total_profit",
        help="Column used to rank tickers (default total_profit)",
    )
    parser.add_argument(
        "--min-sort",
        type=float,
        default=0.0,
        help="Minimum value for sort column (default 0)",
    )
    parser.add_argument(
        "--filter",
        default="",
        help=(
            "Optional filter to apply. 'basic' requires trade_success_pct > 49, "
            "total_profit > total_trades/4, and avg_trade_time > 5"
        ),
    )
    return parser.parse_args()


def load_history(path: Path, start: pd.Timestamp, end: pd.Timestamp, rng: int) -> pd.DataFrame:
    """Return rows from ``path`` that match the requested parameters."""

    df = pd.read_csv(path)

    # Require explicit start/end columns so we can guarantee the row matches the
    # analysis period exactly. If they're missing, no rows are considered.
    if "start_date" not in df.columns or "end_date" not in df.columns:
        return pd.DataFrame(columns=df.columns)

    df["start_date"] = pd.to_datetime(df["start_date"], errors="coerce")
    df["end_date"] = pd.to_datetime(df["end_date"], errors="coerce")
    df = df[(df["start_date"] == start) & (df["end_date"] == end)]

    # The range column can be named either ``open_range_minutes`` or ``range``.
    if "open_range_minutes" in df.columns:
        df = df[df["open_range_minutes"] == rng]
    elif "range" in df.columns:
        df = df[df["range"] == rng]
    else:
        return pd.DataFrame(columns=df.columns)

    return df


def iter_trade_files(root: Path) -> Iterable[Path]:
    for letter in sorted(root.iterdir()):
        if not letter.is_dir() or len(letter.name) != 1:
            continue
        yield from letter.glob("*.csv")


def main() -> None:
    args = parse_args()
    start = pd.to_datetime(args.start)
    end = pd.to_datetime(args.end)

    root = Path("tickers")
    if not root.is_dir():
        print(f"Tickers directory not found: {root}")
        return

    rows: list[dict[str, float | str]] = []
    for csv_path in iter_trade_files(root):
        ticker = csv_path.stem.upper()
        df = load_history(csv_path, start, end, args.range)
        if df.empty:
            continue

        row: dict[str, float | str] = {"ticker": ticker}

        total_trades = df.get("total_trades")
        if total_trades is not None:
            row["total_trades"] = total_trades.sum()
        else:
            row["total_trades"] = len(df)

        if "total_profit" in df.columns:
            row["total_profit"] = df["total_profit"].sum()
        if "total_top_profit" in df.columns:
            row["total_top_profit"] = df["total_top_profit"].sum()

        if "trade_success_pct" in df.columns:
            trades = df["total_trades"] if "total_trades" in df.columns else 1
            weighted = (df["trade_success_pct"] * trades).sum()
            row["trade_success_pct"] = weighted / row["total_trades"] if row["total_trades"] else 0.0
        elif "trade_success_rate" in df.columns:
            trades = df["total_trades"] if "total_trades" in df.columns else 1
            weighted = (df["trade_success_rate"] * 100 * trades).sum()
            row["trade_success_pct"] = weighted / row["total_trades"] if row["total_trades"] else 0.0

        if "avg_trade_time" in df.columns:
            trades = df["total_trades"] if "total_trades" in df.columns else 1
            weighted = (df["avg_trade_time"] * trades).sum()
            row["avg_trade_time"] = weighted / row["total_trades"] if row["total_trades"] else 0.0

        if "start_date" in df.columns:
            row["start_date"] = pd.to_datetime(df["start_date"]).min().strftime("%Y-%m-%d")
        if "end_date" in df.columns:
            row["end_date"] = pd.to_datetime(df["end_date"]).max().strftime("%Y-%m-%d")
        if "open_range_minutes" in df.columns:
            row["range"] = df["open_range_minutes"].iloc[0]
        elif "range" in df.columns:
            row["range"] = df["range"].iloc[0]

        if args.filter == "basic":
            if (
                "trade_success_pct" not in row
                or row["trade_success_pct"] <= 49
                or "total_profit" not in row
                or row["total_profit"] <= row["total_trades"] / 4
                or "avg_trade_time" not in row
                or row["avg_trade_time"] <= 5
            ):
                continue

        if args.sort not in row or row.get(args.sort, 0) <= args.min_sort:
            continue

        rows.append(row)

    if not rows:
        print("No matching data found")
        return

    result = pd.DataFrame(rows)
    result = result.sort_values(by=args.sort, ascending=False)

    for col in [
        "trade_success_pct",
        "total_profit",
        "total_top_profit",
        "avg_trade_time",
    ]:
        if col in result.columns:
            result[col] = result[col].map(lambda x: f"{x:.2f}")

    if tabulate:
        print(tabulate(result, headers="keys", tablefmt="grid", showindex=False))
    else:
        print(result.to_string(index=False))


if __name__ == "__main__":
    main()
