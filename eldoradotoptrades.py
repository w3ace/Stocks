#!/usr/bin/env python3
"""List top tickers from trade history.

The script reads ``./tickers/<start-date>-<end-date>-<filter>/<range>.csv``
generated by :mod:`backtest`. It filters rows between the specified
``--start`` and ``--end`` dates, matching the ``--range`` value when an
``open_range_minutes`` or ``range`` column is present.
Tickers are ordered by the column specified with ``--sort`` and only
included when that column's value is greater than ``--min-sort``. Pass
``--sample basic`` to apply a basic quality filter to results.
"""

from __future__ import annotations

import argparse
from pathlib import Path

import pandas as pd

try:
    from tabulate import tabulate
except Exception:  # ImportError or other
    tabulate = None


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="List top tickers from trades")
    parser.add_argument("--start", required=True, help="Start date YYYY-MM-DD")
    parser.add_argument("--end", required=True, help="End date YYYY-MM-DD")
    parser.add_argument(
        "--range",
        type=int,
        default=30,
        help="Opening range minutes (default 30)",
    )
    parser.add_argument(
        "--sort",
        default="total_profit",
        help="Column used to rank tickers (default total_profit)",
    )
    parser.add_argument(
        "--min-sort",
        type=float,
        default=0.0,
        help="Minimum value for sort column (default 0)",
    )
    parser.add_argument(
        "--filter",
        default="",
        help="Directory filter used to locate ticker data",
    )
    parser.add_argument(
        "--sample",
        default="",
        help=(
            "Optional filter applied to results. 'basic' requires "
            "trade_success_pct > 49, total_profit > total_trades/4, and "
            "avg_trade_time > 5"
        ),
    )
    parser.add_argument(
        "--output",
        choices=["table", "portfolio"],
        default="table",
        help="Display format. 'portfolio' prints tickers on one line",
    )
    return parser.parse_args()


def load_history(path: Path, start: pd.Timestamp, end: pd.Timestamp, rng: int) -> pd.DataFrame:
    """Return rows from ``path`` that match the requested parameters."""

    df = pd.read_csv(path)

    # Require explicit start/end columns so we can guarantee the row matches the
    # analysis period exactly. If they're missing, no rows are considered.
    if "start_date" not in df.columns or "end_date" not in df.columns:
        return pd.DataFrame(columns=df.columns)

    df["start_date"] = pd.to_datetime(df["start_date"], errors="coerce")
    df["end_date"] = pd.to_datetime(df["end_date"], errors="coerce")
    df = df[(df["start_date"] == start) & (df["end_date"] == end)]

    # The range column can be named either ``open_range_minutes`` or ``range``.
    if "open_range_minutes" in df.columns:
        df = df[df["open_range_minutes"] == rng]
    elif "range" in df.columns:
        df = df[df["range"] == rng]
    else:
        return pd.DataFrame(columns=df.columns)

    return df


def main() -> None:
    args = parse_args()
    start = pd.to_datetime(args.start)
    end = pd.to_datetime(args.end)

    root = Path("tickers") / f"{args.start}-{args.end}-{args.filter.replace(' ', '_')}"
    data_file = root / f"{args.range}.csv"
    if not data_file.is_file():
        print(f"Data file not found: {data_file}")
        return

    df = load_history(data_file, start, end, args.range)
    if df.empty:
        print("No matching data found")
        return

    rows: list[dict[str, float | str]] = []
    for ticker, df in df.groupby("ticker"):
        ticker = str(ticker).upper()
        
        row: dict[str, float | str] = {"ticker": ticker}

        if "total_trades" in df.columns:
            row["total_trades"] = df["total_trades"].sum()
        else:
            row["total_trades"] = len(df)

        if "total_profit" in df.columns:
            row["total_profit"] = df["total_profit"].sum()
        if "total_top_profit" in df.columns:
            row["total_top_profit"] = df["total_top_profit"].sum()

        if "trade_success_pct" in df.columns:
            trades = df["total_trades"] if "total_trades" in df.columns else 1
            weighted = (df["trade_success_pct"] * trades).sum()
            row["trade_success_pct"] = weighted / row["total_trades"] if row["total_trades"] else 0.0
        elif "trade_success_rate" in df.columns:
            trades = df["total_trades"] if "total_trades" in df.columns else 1
            weighted = (df["trade_success_rate"] * 100 * trades).sum()
            row["trade_success_pct"] = weighted / row["total_trades"] if row["total_trades"] else 0.0

        if "avg_trade_time" in df.columns:
            trades = df["total_trades"] if "total_trades" in df.columns else 1
            weighted = (df["avg_trade_time"] * trades).sum()
            row["avg_trade_time"] = weighted / row["total_trades"] if row["total_trades"] else 0.0

        if "start_date" in df.columns:
            row["start_date"] = pd.to_datetime(df["start_date"]).min().strftime("%Y-%m-%d")
        if "end_date" in df.columns:
            row["end_date"] = pd.to_datetime(df["end_date"]).max().strftime("%Y-%m-%d")
        if "open_range_minutes" in df.columns:
            row["range"] = df["open_range_minutes"].iloc[0]
        elif "range" in df.columns:
            row["range"] = df["range"].iloc[0]

        if args.sample == "basic":
            if (
                "trade_success_pct" not in row
                or row["trade_success_pct"] <= 59
                or "total_profit" not in row
                or row["total_profit"] <= row["total_trades"] / 4
                or "avg_trade_time" not in row
                or row["avg_trade_time"] <= 5
            ):
                continue

        if args.sort not in row or row.get(args.sort, 0) <= args.min_sort:
            continue

        rows.append(row)

    if not rows:
        print("No matching data found")
        return

    result = pd.DataFrame(rows)
    result = result.sort_values(by=args.sort, ascending=False)

    for col in [
        "trade_success_pct",
        "total_profit",
        "total_top_profit",
        "avg_trade_time",
    ]:
        if col in result.columns:
            result[col] = result[col].map(lambda x: f"{x:.2f}")

    if tabulate:
        print(tabulate(result, headers="keys", tablefmt="grid", showindex=False))
    else:
        print(result.to_string(index=False))

    if args.output == "portfolio":
        print(" ".join(result["ticker"].tolist()))


if __name__ == "__main__":
    main()
