#!/usr/bin/env python3
"""List top tickers from trade history.

The script searches ``./trades/<LETTER>/<TICKER>.csv`` for per ticker
trade summaries generated by backtest runs. It filters rows between the
specified ``--start`` and ``--end`` dates, matching the ``--range``
value when an ``open_range_minutes`` or ``range`` column is present.
Tickers are ordered by the column specified with ``--sort`` and only
included when that column's value is greater than ``--min-sort``.
"""

from __future__ import annotations

import argparse
from pathlib import Path
from typing import Iterable

import pandas as pd

try:
    from tabulate import tabulate
except Exception:  # ImportError or other
    tabulate = None


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="List top tickers from trades")
    parser.add_argument("--start", required=True, help="Start date YYYY-MM-DD")
    parser.add_argument("--end", required=True, help="End date YYYY-MM-DD")
    parser.add_argument(
        "--range",
        type=int,
        default=30,
        help="Opening range minutes (default 30)",
    )
    parser.add_argument(
        "--sort",
        default="total_profit",
        help="Column used to rank tickers (default total_profit)",
    )
    parser.add_argument(
        "--min-sort",
        type=float,
        default=0.0,
        help="Minimum value for sort column (default 0)",
    )
    return parser.parse_args()


def load_history(path: Path, start: pd.Timestamp, end: pd.Timestamp, rng: int) -> pd.DataFrame:
    df = pd.read_csv(path)
    if "analysis_time" in df.columns:
        df["analysis_time"] = pd.to_datetime(df["analysis_time"], errors="coerce")
        df = df[(df["analysis_time"] >= start) & (df["analysis_time"] <= end)]
    elif "date" in df.columns:
        df["date"] = pd.to_datetime(df["date"], errors="coerce")
        df = df[(df["date"] >= start) & (df["date"] <= end)]

    if "open_range_minutes" in df.columns:
        df = df[df["open_range_minutes"] == rng]
    elif "range" in df.columns:
        df = df[df["range"] == rng]

    return df


def iter_trade_files(root: Path) -> Iterable[Path]:
    for letter in sorted(root.iterdir()):
        if not letter.is_dir() or len(letter.name) != 1:
            continue
        yield from letter.glob("*.csv")


def main() -> None:
    args = parse_args()
    start = pd.to_datetime(args.start)
    end = pd.to_datetime(args.end)

    root = Path("trades")
    if not root.is_dir():
        print(f"Trades directory not found: {root}")
        return

    rows: list[dict[str, float | str]] = []
    for csv_path in iter_trade_files(root):
        ticker = csv_path.stem.upper()
        df = load_history(csv_path, start, end, args.range)
        if df.empty or args.sort not in df.columns:
            continue
        value = df[args.sort].sum()
        if value <= args.min_sort:
            continue
        rows.append({"Ticker": ticker, args.sort: value})

    if not rows:
        print("No matching data found")
        return

    result = pd.DataFrame(rows)
    result = result.sort_values(by=args.sort, ascending=False)

    if tabulate:
        print(tabulate(result, headers="keys", tablefmt="grid", showindex=False))
    else:
        print(result.to_string(index=False))


if __name__ == "__main__":
    main()
